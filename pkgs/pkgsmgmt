#!/usr/bin/env python
# encoding: utf-8

import sys
import os
import yaml
import argparse
from pprint import pformat as pf
from git import Repo, remote


import logging

# Set up the logger
logger = logging.getLogger(__name__)
# Use a console handler, set it to debug by default
logger_ch = logging.StreamHandler()
logger.setLevel(logging.DEBUG)
log_formatter = logging.Formatter(('%(asctime)s %(levelname)s:%(process)s'
                                   ' %(lineno)s:%(module)s:%(funcName)s()'
                                   ' %(message)s'))
logger_ch.setFormatter(log_formatter)
logger.addHandler(logger_ch)

HOME = os.getenv('HOME')
PKGS_DIR = "{}/pkgs".format(HOME)
PKGS_CONFIG = "{}/pkgs.yml".format(PKGS_DIR)


# load the yaml file
pkgs_cfg = yaml.load(open(PKGS_CONFIG))


class pkgRP(remote.RemoteProgress):

    def line_dropped(self, line):
        """todo: Docstring for line_dropped

        :param line: arg description
        :type line: type description
        :return:
        :rtype:
        """
        print("Line Dropped: '{}'".format(line))
    #line_dropped()

    def update(self, op_code, cur_count, max_count=None, message=''):
        """todo: Docstring for update

        :param op_code: arg description
        :type op_code: type description
        :param cur_count: arg description
        :type cur_count: type description
        :param max_count: arg description
        :type max_count: type description
        :param message: arg description
        :type message: type description
        :return:
        :rtype:
        """

        print(("Update, op_code:{}, cur_count:{}, max_count:{}, "
              "message:{}").format(op_code, cur_count, max_count, message))
    #update()
#pkgRP


def _get_pkg_repos(base_dir):
    """todo: Docstring for _get_pkg_list

    :param base_dir: arg description
    :type base_dir: type description
    :return:
    :rtype:
    """
    ret = []

    if not os.path.exists(base_dir):
        return ret

    for f in os.listdir(base_dir):
        pdir = os.path.join(base_dir, f)
        if os.path.isdir(pdir):
            pg_dir = os.path.join(pdir, '.git')
            if os.path.isdir(pg_dir):
                repo = Repo(pg_dir)
                assert not repo.bare, \
                    "The git repo {} is not initialized".format(pg_dir)
                ret.append({
                    'repo': repo,
                    'name': os.path.basename(repo.working_dir),
                    'status_lines': [x.strip() for x in
                                     repo.git.status(porcelain=True).split(
                                         '\n')
                                     ],
                })
    # end for f in os

    return ret
#_get_pkg_repos()


def _print_status(pkgs):
    """todo: Docstring for _print_status

    :param pkgs: arg description
    :type pkgs: type description
    :return:
    :rtype:
    """

    report = []
    fmt = "\n{}::{}\n\t{}"
    # logger.debug(pkgs)
    for pkg in pkgs:
        status = 'CLEAN'
        repo = pkg['repo']
        if repo.is_dirty():
            status = '\n\t'.join(pkg['status_lines'])

        print(fmt).format(
            pkg['name'],
            repo.active_branch,
            status)
    # end for pkg in pkgs
    print('\n')
#_print_status()


def _update(pkgs):
    """todo: Docstring for _update

    :param pkgs: arg description
    :type pkgs: type description
    :return:
    :rtype:
    """

    for pkg in pkgs:
        repo = pkg['repo']
        if not repo.is_dirty():
            print("updating {}".format(pkg['name']))
            origin = repo.remotes.origin
            res = origin.pull(progress=pkgRP())
            for info in res:
                print(pf(res))
            # end for info in res
    # end for pkg in pkgs

#_update()


def _push(pkgs):
    """todo: Docstring for _push

    :param pkgs: arg description
    :type pkgs: type description
    :return:
    :rtype:
    """

    for pkg in pkgs:
        repo = pkg['repo']
        if not repo.is_dirty():
            print("pushing {}".format(pkg['name']))
            origin = repo.remotes.origin
            res = origin.push(progress=pkgRP())
            for info in res:
                print(pf(res))
            # end for info in res
        else:
            print("{} is dirty".format(pkg['name']))
    # end for pkg in pkgs
#_push()


def init_argsparse():

    parser = argparse.ArgumentParser()
    parser.add_argument('--status', '-s', action="store_true",
                        dest='status', default=True)
    parser.add_argument('--update', '-u', action="store_true",
                        dest='update', default=False)
    parser.add_argument('--push', '-p', action="store_true",
                        dest='push', default=False)
    parser.add_argument('--pkgdir', '-d', default=PKGS_DIR, dest='pkgsdir')

    return parser.parse_args()
#init_argsparse()


def main():
    args = init_argsparse()
    pkgs = _get_pkg_repos(args.pkgsdir)

    if args.update:
        # Update all pkgs that aren't dirty.
        _update(pkgs)

    if args.push:
        _push(pkgs)

    _print_status(pkgs)
# main()

if __name__ == '__main__':
    main()

# vim:set ft=python:
